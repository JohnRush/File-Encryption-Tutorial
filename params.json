{
  "name": "C# File Encryption Tutorial",
  "tagline": "",
  "body": "# Overview\r\nThis tutorial will show you how to encrypt files using the .NET Crypto API. We start off simple and add features one step at a time. All of the code is available for each step, so you can follow along or just play with the final version if you prefer.\r\n\r\n# Tutorial 1\r\nIn this tutorial we start with an empty project and add just enough code to encrypt a single file. The result is a console program that, given a file name, will encrypt that file and write it out to a new file. A sample of usage might look something like this:\r\n\r\n`tutorial01 myfile.txt myfile.crypto`\r\n\r\n## Symmetric Encryption\r\nBefore we jump into the code, let's talk a little bit about the nature of cryptography. If you want to securely encrypt anything, you don't want to create your own encryption algorithms. There are lots of ways to encrypt data and most of them are wrong. Stick to proven methods that have been rigorously tested. Fortunately, we have several such algorithms available in .NET right out of the box, so we don't have to look to far.\r\n\r\nWhen we encrypt lots of data (such as a file) we typically use a *symmetric algorithm*. In cryptography when we use the term *symmetric* we mean that the same credentials that are used to encrypt the data are used to decrypt the data. A common example of this is when you password protect a zip archive. You use a password when you lock the archive and you must use the same password to unlock the archive. If you lose or forget the password, you can't access the archive any more.\r\n\r\nThe current standard symmetric algorithm is called [AES (Advanced Encryption Standard)](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard). It is heavily tested and relied upon by our government. It is definitely good enough for us and it is part of the .NET Crypto API.\r\n\r\n## A Basic File Copier\r\nStart off by creating a new console project. Before we get into the details of encryption, let's get some basic functionality working. We simply want to copy the input file to the output file without making any changes to it. This way, we know we have something working that we can build on.\r\n\r\n    using System;\r\n    using System.IO;\r\n    using System.Security.Cryptography;\r\n\r\n    namespace Tutorial01\r\n    {\r\n        class Program\r\n        {\r\n            static void Main(string[] args)\r\n            {\r\n                if (args.Length != 2)\r\n                {\r\n                    Console.WriteLine(\"You must provide the name of a file to read and the name of a file to write.\");\r\n                    return;\r\n                }\r\n\r\n                var sourceFilename = args[0];\r\n                var destinationFilename = args[1];\r\n    \r\n                using (var sourceStream = File.OpenRead(sourceFilename))\r\n                using (var destinationStream = File.Create(destinationFilename))\r\n                {\r\n                    sourceStream.CopyTo(destinationStream);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nIn the above code, that we require two arguments be provided. If not, we return with a friendly tip. Otherwise, we get the source file name as the first argument and the destination file name as the second argument. You might want to add some code to make sure the source file exists, but I'm going to skip that so we can focus on the core mechanics. If you are not familiar with the `using` statement, you may want to [look that up](https://msdn.microsoft.com/en-us/library/yh598w02.aspx?f=255&MSPPError=-2147217396). In C# that is a way to cleanup objects when we are done with them. It is particularly useful for file operations.\r\n\r\nThe real work is the five lines of code that start on line 19 with the `using` statement. We open our source file for reading (line 19) and we create our destination file for writing (line 20). We get a stream for each file and simply copy the contents of one file to the other using the `CopyTo` method (line 22). If you are following along, this is a good time to make sure you can get this working and that you can create the target file identical to the source.\r\n\r\n## Encryption At Last\r\nSince we are already copying files using `Stream` objects, we use the `CryptoStream` API to add encryption to the existing operation.\r\n\r\n    using System;\r\n    using System.IO;\r\n    using System.Security.Cryptography;\r\n\r\n    namespace Tutorial01\r\n    {\r\n        class Program\r\n        {\r\n            static void Main(string[] args)\r\n            {\r\n                if (args.Length != 2)\r\n                {\r\n                    Console.WriteLine(\"You must provide the name of a file to read and the name of a file to write.\");\r\n                    return;\r\n                }\r\n\r\n                var sourceFilename = args[0];\r\n                var destinationFilename = args[1];\r\n\r\n                using (var sourceStream = File.OpenRead(sourceFilename))\r\n                using (var destinationStream = File.Create(destinationFilename))\r\n                using (var provider = new AesCryptoServiceProvider())\r\n                using (var cryptoTransform = provider.CreateEncryptor())\r\n                using (var cryptoStream = new CryptoStream(destinationStream, cryptoTransform, CryptoStreamMode.Write))\r\n                {\r\n                    sourceStream.CopyTo(cryptoStream);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nThe only thing we did here was add a few lines of code (lines 22, 23, 24) and made a slight alteration to the stream copy (line 26). Line 22 creates a new `AesCryptoServiceProvider`. This provider has information about *how* we want to encrypt. We will look at that more later. For now, we just want to use it to create the decryptor transform that we need (line 23). If we wanted to do things the hard way we could use the transform directly, but it's easier to use the `CryptoStream`. On line 24 we create the `CryptoStream`. We need to give it the stream to write to, the transform (in our case the encryptor) and let it know that we want this to be a writable stream. The `CryptoStream` wraps our destination stream. That is, it takes the bytes that need to be written and processes (encrypts) the bytes and then sends the processed bytes to the destination stream. We basically inject our encryption between the two file streams that we are already using. Line 26 shows how we achieve this by calling `CopyTo` on the sourceStream and providing our new `CryptoStream`.\r\n\r\nWhen you run this program, your output file will be securely encrypted. You should test it to make sure. Your output file should like like a bunch of seemingly random bytes.\r\n\r\n## Wait a Minute!\r\nIf everything went well, you have an encrypted file. But remember, above, we mentioned symmetric encryption? Symmetric encryption uses the same credentials to decrypt and encrypt the data. That suggests that we need to have some kind of credentials in the first place. AES uses a *key* and supports different key sizes. By default the key length is 256 bits (32 bytes). A key is simply any 32 bytes of data we want to use. Whatever key we use to encrypt the data will be needed to decrypt the data. If we decrypt the data with the wrong key we will get garbage. But what key did we use above? We don't seem to specify one at all.\r\n\r\nWhen an `AesCryptoServiceProvider` is created, it automatically creates a secure random key. We are just using whatever it randomly created. That is fine, but if we are ever going to decrypt the file we will need to know what the key is. Let's add some code to display the AES encryption key that was used.\r\n\r\n            {\r\n                sourceStream.CopyTo(cryptoStream);\r\n                Console.WriteLine(System.Convert.ToBase64String(provider.Key));\r\n            }\r\n\r\nNot so tough. We just get the `Key` property of the `AesCryptoServiceProvider`. The key is an array of bytes, which won't print very nicely. Using `System.Convert.ToBase64String` makes it so we can represent all of those byte values as printable characters. We could have converted the byte array to a hex string or any number of things, but [Base64](https://en.wikipedia.org/wiki/Base64) is convenient.\r\n\r\n## Oh, And One More Thing...\r\nWhen using AES we have the key, which is secret and should be protected. But there is another piece of data that is used to make the encryption stronger. It is called the IV (initialization vector). The IV tells the encryptor how to modify the first block to prevent against certain attacks. Changing the IV will change the encryption/decryption results, so we are going to need to have that available when we decrypt the file. The IV is not secret, however. So we don't need to hide it. Therefore, we can write it directly to the output file we are already writing. That way we can't possibly lose it. We do have to be careful though. If we write the IV to the file and the bytes get encrypted then we won't be able to get them back out (since we need them to do the decryption). We have to make sure to write the IV before any encryption happens. It only takes one line of code:\r\n\r\n    destinationStream.Write(provider.IV, 0, provider.IV.Length);\r\n\r\nBut, where we put that code is **very important**:\r\n\r\n            {\r\n                destinationStream.Write(provider.IV, 0, provider.IV.Length);\r\n                sourceStream.CopyTo(cryptoStream);\r\n                Console.WriteLine(System.Convert.ToBase64String(provider.Key));\r\n            }\r\n\r\nWe can write directly to the destination stream (not the `CryptoStream`) before the ecryption that happens in the call to `CopyTo`. That way, the IV is not encrypted, but is right at the beginning of the destination file.\r\n\r\nNow we are looking pretty good. We encrypt a file. We save the IV in the file where it is easy to find and we display the key, so you save it in a secret place until it is needed to decrypt the file.\r\n\r\n# Tutorial 2\r\nIn this tutorial we decrypt an ecrypted file, restoring it to its original state. To do this, we need three things: the key used to encrypt the file, the IV used to encrypt the file, and the encrypted file. From our last tutorial, we display the key in the console after encrypting the file and we store the IV at the front of the file. So we have averything we need.\r\n\r\nOur current program accepts two filenames as command line arguments. Let's modify it to accept a third argument, the decryption key. Because it help us enderstand how the program works, let's go ahead and update the help text in the program.\r\n\r\n            if (args.Length < 2 || args.Length > 3)\r\n            {\r\n                Console.WriteLine(\"Encrypt or Decrypt a file.\");\r\n                Console.WriteLine(\"\\nTutorial02 source destination [key]\\n\");\r\n                Console.WriteLine(\"{0,-15}Specifies the source file.\", \"source\");\r\n                Console.WriteLine(\"{0,-15}Specifies the destination file.\", \"destination\");\r\n                Console.WriteLine(\"{0,-15}The optional decryption key.\", \"key\");\r\n                Console.WriteLine(\"{0,-15}If provided we decrypt, otherwise we encrypt.\", \"\");\r\n                return;\r\n            }\r\n\r\nNotice that we know allow for two or three arguments. If the third argument is provided, we use it as the key for decrypting the source file. Then we need to get the values from the coomand line.\r\n\r\n            var sourceFilename = args[0];\r\n            var destinationFilename = args[1];\r\n\r\n            byte[] key = null;\r\n            if (args.Length == 3)\r\n            {\r\n                key = System.Convert.FromBase64String(args[2]);\r\n            }\r\n\r\nRemember that we wrote out the key using Base64 encoding, so when we get the key we convert it back from Base64 to the byte array that we need. For the rest of the code, we now kow that if we have a key, we want to decrypt the source file. If we don't have a key we want to encrypt the source file. For the existing encryption code we can just wrap it inside an `if` statement.\r\n\r\n            if (key == null)\r\n            {\r\n                using (var sourceStream = File.OpenRead(sourceFilename))\r\n                using (var destinationStream = File.Create(destinationFilename))\r\n                using (var provider = new AesCryptoServiceProvider())\r\n                using (var cryptoTransform = provider.CreateEncryptor())\r\n                using (var cryptoStream = new CryptoStream(destinationStream, cryptoTransform, CryptoStreamMode.Write))\r\n                {\r\n                    destinationStream.Write(provider.IV, 0, provider.IV.Length);\r\n                    sourceStream.CopyTo(cryptoStream);\r\n                    Console.WriteLine(System.Convert.ToBase64String(provider.Key));\r\n                }\r\n            }\r\n\r\nNothing changed from our existing encryption code; we just put it all in the `if` block.\r\n\r\nLast updated: April 5, 2015",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}