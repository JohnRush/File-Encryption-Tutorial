<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="C# File Encryption Tutorial : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>C# File Encryption Tutorial</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/JohnRush/File-Encryption-Tutorial">View on GitHub</a>

          <h1 id="project_title">C# File Encryption Tutorial</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/JohnRush/File-Encryption-Tutorial/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/JohnRush/File-Encryption-Tutorial/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h1>

<p>This tutorial will show you how to encrypt files using the .NET Crypto API. We start off simple and add features one step at a time. All of the code is available for each step, so you can follow along or just play with the final version if you prefer.</p>

<h1>
<a id="tutorial-1" class="anchor" href="#tutorial-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Tutorial 1</h1>

<p>In this tutorial we start with an empty project and add just enough code to encrypt a single file. The result is a console program that, given a file name, will encrypt that file and write it out to a new file. A sample of usage might look something like this:</p>

<p><code>tutorial01 myfile.txt myfile.crypto</code></p>

<h2>
<a id="symmetric-encryption" class="anchor" href="#symmetric-encryption" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Symmetric Encryption</h2>

<p>Before we jump into the code, let's talk a little bit about the nature of cryptography. If you want to securely encrypt anything, you don't want to create your own encryption algorithms. There are lots of ways to encrypt data and most of them are wrong. Stick to proven methods that have been rigorously tested. Fortunately, we have several such algorithms available in .NET right out of the box, so we don't have to look to far.</p>

<p>When we encrypt lots of data (such as a file) we typically use a <em>symmetric algorithm</em>. In cryptography when we use the term <em>symmetric</em> we mean that the same credentials that are used to encrypt the data are used to decrypt the data. A common example of this is when you password protect a zip archive. You use a password when you lock the archive and you must use the same password to unlock the archive. If you lose or forget the password, you can't access the archive any more.</p>

<p>The current standard symmetric algorithm is called <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES (Advanced Encryption Standard)</a>. It is heavily tested and relied upon by our government. It is definitely good enough for us and it is part of the .NET Crypto API.</p>

<h2>
<a id="a-basic-file-copier" class="anchor" href="#a-basic-file-copier" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A Basic File Copier</h2>

<p>Start off by creating a new console project. Before we get into the details of encryption, let's get some basic functionality working. We simply want to copy the input file to the output file without making any changes to it. This way, we know we have something working that we can build on.</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;

namespace Tutorial01
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length != 2)
            {
                Console.WriteLine("You must provide the name of a file to read and the name of a file to write.");
                return;
            }

            var sourceFilename = args[0];
            var destinationFilename = args[1];

            using (var sourceStream = File.OpenRead(sourceFilename))
            using (var destinationStream = File.Create(destinationFilename))
            {
                sourceStream.CopyTo(destinationStream);
            }
        }
    }
}
</code></pre>

<p>In the above code, that we require two arguments be provided. If not, we return with a friendly tip. Otherwise, we get the source file name as the first argument and the destination file name as the second argument. You might want to add some code to make sure the source file exists, but I'm going to skip that so we can focus on the core mechanics. If you are not familiar with the <code>using</code> statement, you may want to <a href="https://msdn.microsoft.com/en-us/library/yh598w02.aspx?f=255&amp;MSPPError=-2147217396">look that up</a>. In C# that is a way to cleanup objects when we are done with them. It is particularly useful for file operations.</p>

<p>The real work is the five lines of code that start on line 19 with the <code>using</code> statement. We open our source file for reading (line 19) and we create our destination file for writing (line 20). We get a stream for each file and simply copy the contents of one file to the other using the <code>CopyTo</code> method (line 22). If you are following along, this is a good time to make sure you can get this working and that you can create the target file identical to the source.</p>

<h2>
<a id="encryption-at-last" class="anchor" href="#encryption-at-last" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Encryption At Last</h2>

<p>Since we are already copying files using <code>Stream</code> objects, we use the <code>CryptoStream</code> API to add encryption to the existing operation.</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;

namespace Tutorial01
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length != 2)
            {
                Console.WriteLine("You must provide the name of a file to read and the name of a file to write.");
                return;
            }

            var sourceFilename = args[0];
            var destinationFilename = args[1];

            using (var sourceStream = File.OpenRead(sourceFilename))
            using (var destinationStream = File.Create(destinationFilename))
            using (var provider = new AesCryptoServiceProvider())
            using (var cryptoTransform = provider.CreateEncryptor())
            using (var cryptoStream = new CryptoStream(destinationStream, cryptoTransform, CryptoStreamMode.Write))
            {
                sourceStream.CopyTo(cryptoStream);
            }
        }
    }
}
</code></pre>

<p>The only thing we did here was add a few lines of code (lines 22, 23, 24) and made a slight alteration to the stream copy (line 26). Line 22 creates a new <code>AesCryptoServiceProvider</code>. This provider has information about <em>how</em> we want to encrypt. We will look at that more later. For now, we just want to use it to create the decryptor transform that we need (line 23). If we wanted to do things the hard way we could use the transform directly, but it's easier to use the <code>CryptoStream</code>. On line 24 we create the <code>CryptoStream</code>. We need to give it the stream to write to, the transform (in our case the encryptor) and let it know that we want this to be a writable stream. The <code>CryptoStream</code> wraps our destination stream. That is, it takes the bytes that need to be written and processes (encrypts) the bytes and then sends the processed bytes to the destination stream. We basically inject our encryption between the two file streams that we are already using. Line 26 shows how we achieve this by calling <code>CopyTo</code> on the sourceStream and providing our new <code>CryptoStream</code>.</p>

<p>When you run this program, your output file will be securely encrypted. You should test it to make sure. Your output file should like like a bunch of seemingly random bytes.</p>

<h2>
<a id="wait-a-minute" class="anchor" href="#wait-a-minute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Wait a Minute!</h2>

<p>If everything went well, you have an encrypted file. But remember, above, we mentioned symmetric encryption? Symmetric encryption uses the same credentials to decrypt and encrypt the data. That suggests that we need to have some kind of credentials in the first place. AES uses a <em>key</em> and supports different key sizes. By default the key length is 256 bits (32 bytes). A key is simply any 32 bytes of data we want to use. Whatever key we use to encrypt the data will be needed to decrypt the data. If we decrypt the data with the wrong key we will get garbage. But what key did we use above? We don't seem to specify one at all.</p>

<p>When an <code>AesCryptoServiceProvider</code> is created, it automatically creates a secure random key. We are just using whatever it randomly created. That is fine, but if we are ever going to decrypt the file we will need to know what the key is. Let's add some code to display the AES encryption key that was used.</p>

<pre><code>        {
            sourceStream.CopyTo(cryptoStream);
            Console.WriteLine(System.Convert.ToBase64String(provider.Key));
        }
</code></pre>

<p>Not so tough. We just get the <code>Key</code> property of the <code>AesCryptoServiceProvider</code>. The key is an array of bytes, which won't print very nicely. Using <code>System.Convert.ToBase64String</code> makes it so we can represent all of those byte values as printable characters. We could have converted the byte array to a hex string or any number of things, but <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> is convenient.</p>

<h2>
<a id="oh-and-one-more-thing" class="anchor" href="#oh-and-one-more-thing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Oh, And One More Thing...</h2>

<p>When using AES we have the key, which is secret and should be protected. But there is another piece of data that is used to make the encryption stronger. It is called the IV (initialization vector). The IV tells the encryptor how to modify the first block to prevent against certain attacks. Changing the IV will change the encryption/decryption results, so we are going to need to have that available when we decrypt the file. The IV is not secret, however. So we don't need to hide it. Therefore, we can write it directly to the output file we are already writing. That way we can't possibly lose it. We do have to be careful though. If we write the IV to the file and the bytes get encrypted then we won't be able to get them back out (since we need them to do the decryption). We have to make sure to write the IV before any encryption happens. It only takes one line of code:</p>

<pre><code>destinationStream.Write(provider.IV, 0, provider.IV.Length);
</code></pre>

<p>But, where we put that code is <strong>very important</strong>:</p>

<pre><code>        {
            destinationStream.Write(provider.IV, 0, provider.IV.Length);
            sourceStream.CopyTo(cryptoStream);
            Console.WriteLine(System.Convert.ToBase64String(provider.Key));
        }
</code></pre>

<p>We can write directly to the destination stream (not the <code>CryptoStream</code>) before the ecryption that happens in the call to <code>CopyTo</code>. That way, the IV is not encrypted, but is right at the beginning of the destination file.</p>

<p>Now we are looking pretty good. We encrypt a file. We save the IV in the file where it is easy to find and we display the key, so you save it in a secret place until it is needed to decrypt the file.</p>

<p>Last updated: April 5, 2015</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">C# File Encryption Tutorial maintained by <a href="https://github.com/JohnRush">JohnRush</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
